<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Socket.IO: the cross-browser WebSocket for realtime apps.</title>
		<meta name="description" content="Socket.IO aims to make realtime apps possible in every browser and mobile device, blurring the differences between the different transport mechanisms">
		<link rel="shortcut icon" href="images/favicon.ico">
		<link href="css/main.css" rel="stylesheet" media="all">
		<!--[if lt IE 9]>
			<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
	</head>
	<body>

		<header>
			<h3>Introducing</h3>
			<h1><a href="./">Socket.IO</a></h1>
			<a href="http://github.com/jxck/socket.io/" class="download">v.9</a>
		</header>

		<div id="content">

			<section>
				<form action="http://groups.google.com/group/socket_io/boxsubscribe" id="google-subscribe">
					<a href="http://groups.google.com/group/socket_io"><img src="images/groups.png" alt="Google Groups"></a>
					<div id="google-subscribe-input">
						Email: <input type="text" name="email" id="google-subscribe-email">
						<input type="submit" name="go" value="Subscribe">
					</div>
				</form>
			</section>

			<section>
				<nav>
					<a href="#home" id="menu-home">Home</a>
					<a href="#how-to-use" id="menu-how-to-use">How to use</a>
					<a href="#browser-support" id="menu-browser-support">Browser Support</a>
					<a href="#faq" id="menu-faq">FAQ</a>
					<a href="http://github.com/jxck/socket.io/wiki/">Wiki</a>
				</nav>
			</section>


			<!-- #home -->
			<div class="page" id="page-home">
				
				<section>
					<h2>What is Socket.IO?</h2>
					<p>
					<!--
						<strong>Socket.IO</strong> aims to make realtime apps possible in every
						browser and mobile device, blurring the differences between the different
						transport mechanisms. It's care-free realtime 100% in JavaScript.
					-->
						<strong>Socket.IO</strong> は複数の通信メカニズムを抽象化することで、
						全てのブラウザ、デバイスでリアルタイムアプリを実装可能にするために開発されました。
						とても手軽にリアルタイムなアプリを 100% JavaScript で作成可能です。
					</p>
					<div class="example">
						<div class="example-left">
							<h4>Server</h4>
							<pre class="prettyprint">var io = require('socket.io').listen(80);

io.sockets.on('connection', function (socket) {
  socket.emit('news', { hello: 'world' });
  socket.on('my other event', function (data) {
    console.log(data);
  });
});</pre>
						</div>
						<div class="example-right">
							<h4>Client</h4>
							<pre class="prettyprint">&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  var socket = io.connect('http://localhost');
  socket.on('news', function (data) {
    console.log(data);
    socket.emit('my other event', { my: 'data' });
  });
&lt;/script&gt;</pre>
						</div>
					</div>
				</section>
			</div>


			<!-- #how-to-use -->
			<div class="page" id="page-how-to-use">
				<section>
					<h2>How to use</h2>


					<!--
					<h3>Installing</h3>
					-->
					<h3>インストール</h3>
					<pre class="prettyprint">npm install socket.io</pre>
					<br>


					<!--
					<h3>Using with Node HTTP server</h3>
					<p>For this example, simply run `npm install socket.io`</p>
					-->
					<h3>Node の HTTP サーバと連携する</h3>
					<p>この例では、単純に `npm install socket.io` を実行するだけです</p>
					<div class="example">
						<div class="example-left">
							<h4>Server (app.js)</h4>
							<pre class="prettyprint">var app = require('http').createServer(handler)
  , io = require('socket.io').listen(app)
  , fs = require('fs')

app.listen(80);

function handler (req, res) {
  fs.readFile(__dirname + '/index.html',
  function (err, data) {
    if (err) {
      res.writeHead(500);
      return res.end('Error loading index.html');
    }

    res.writeHead(200);
    res.end(data);
  });
}

io.sockets.on('connection', function (socket) {
  socket.emit('news', { hello: 'world' });
  socket.on('my other event', function (data) {
    console.log(data);
  });
});</pre>
						</div>
						<div class="example-right">
							<h4>Client (index.html)</h4>
							<pre class="prettyprint">&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  var socket = io.connect('http://localhost');
  socket.on('news', function (data) {
    console.log(data);
    socket.emit('my other event', { my: 'data' });
  });
&lt;/script&gt;</pre>
						</div>
					</div>


					<!--
					<h3>Using with the Express web framework</h3>
					<p>You can serve normal pages and AJAX requests with Express, and attach your socket.io server</p>
					<p>For this example, simply run `npm install socket.io express`</p>
					-->
					<h3>Express と連携する</h3>
					<p>通常のページ配信や、Ajax リクエストは Express で行い、そこに Socket.IO のサーバを加えます。</p>
					<p>この例では `npm install socket.io express` を実行してください。</p>
					<div class="example">
						<div class="example-left">
							<h4>Server (app.js)</h4>
							<pre class="prettyprint">var app = require('express').createServer()
  , io = require('socket.io').listen(app);

app.listen(80);

app.get('/', function (req, res) {
  res.sendfile(__dirname + '/index.html');
});

io.sockets.on('connection', function (socket) {
  socket.emit('news', { hello: 'world' });
  socket.on('my other event', function (data) {
    console.log(data);
  });
});</pre>
						</div>
						<div class="example-right">
							<h4>Client (index.html)</h4>
							<pre class="prettyprint">&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  var socket = io.connect('http://localhost');
  socket.on('news', function (data) {
    console.log(data);
    socket.emit('my other event', { my: 'data' });
  });
&lt;/script&gt;</pre>
						</div>
					</div>


					<!--
					<h3>Sending and receiving events.</h3>
					<p>Socket.IO allows you to emit and receive custom events. Besides `connect`, `message` and `disconnect`, you can emit custom events:</p>
					-->
					<h3>メッセージの送受信</h3>
					<p>Socket.IO はカスタムイベントの発行/検出ができます。`connect`, `message`, `disconnect` に加えて、好きなイベント名を使うことができます。</p>
					<div class="example">
						<div class="example-left example-left-long">
							<h4>Server</h4>
							<pre class="prettyprint">// note, io.listen(&lt;port&gt;) will create a http server for you
var io = require('socket.io').listen(80);

io.sockets.on('connection', function (socket) {
  io.sockets.emit('this', { will: 'be received by everyone'});

  socket.on('private message', function (from, msg) {
    console.log('I received a private message by ', from, ' saying ', msg);
  });

  socket.on('disconnect', function () {
    io.sockets.emit('user disconnected');
  });
});</pre>
						</div>
					</div>


					<!--
					<h3>Storing data associated to a client</h3>
					<p>Sometimes it's necessary to store data associated with a client that's necessary for the duration of the session.</p>
					-->
					<h3>クライアントに紐づいた、データの保持</h3>
					<p>セッションの保持などのために、クライアントに紐づいたデータを保持する必要がある場合があります。</p>
					<div class="example">
						<div class="example-left">
							<h4>Server</h4>
							<pre class="prettyprint">var io = require('socket.io').listen(80);

io.sockets.on('connection', function (socket) {
  socket.on('set nickname', function (name) {
    socket.set('nickname', name, function () {
      socket.emit('ready');
    });
  });

  socket.on('msg', function () {
    socket.get('nickname', function (err, name) {
      console.log('Chat message by ', name);
    });
  });
});</pre>
						</div>
						<div class="example-right">
							<h4>Client</h4>
							<pre class="prettyprint">&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  var socket = io.connect('http://localhost');
  socket.on('news', function (data) {
    console.log(data);
    socket.emit('my other event', { my: 'data' });
  });
&lt;/script&gt;</pre>
						</div>
					</div>


					<!--
					<h3>Restricting yourself to a namespace.</h3>
					<p>If you have control over all the messages and events emitted for a particular application, using the default / namespace works. If you want to leverage 3rd-party code, or produce code to share with others, socket.io provides a way of namespacing a socket.</p>
					<p>This has the benefit of `multiplexing` a single connection. Instead of socket.io using two `WebSocket` connections, it'll use one.</p>
					-->
					<h3>ネームスペースによる制限</h3>
					<p>もし特定のアプリケーションに発行される全てのメッセージやイベントの制御が出来るのであれば、デフォルトの / のネームスペースで問題なく動作します。もし、サードパーティのコードを取り入れたり、他のコードと共有したい場合のために、 Socket.IO はソケットに対するネームスペースを提供します。</p>
					<p>これは単一コネクション上での `multiplexing(多重通信)` の恩恵であり、二つの `WebSocket` 通信ではなく、一つだけを使って行っています。</p>
					<div class="example">
						<div class="example-left">
							<h4>Server</h4>
							<pre class="prettyprint">var io = require('socket.io').listen(80);

var chat = io
  .of('/chat')
  .on('connection', function (socket) {
    socket.emit('a message', {
        that: 'only'
      , '/chat': 'will get'
    });
    chat.emit('a message', {
        everyone: 'in'
      , '/chat': 'will get'
    });
  });

var news = io
  .of('/news')
  .on('connection', function (socket) {
    socket.emit('item', { news: 'item' });
  });</pre>
						</div>
						<div class="example-right">
							<h4>Client</h4>
							<pre class="prettyprint">&lt;script&gt;
  var chat = io.connect('http://localhost/chat')
    , news = io.connect('http://localhost/news');
  
  chat.on('connect', function () {
    chat.emit('hi!');
  });
  
  news.on('news', function () {
    news.emit('woot');
  });
&lt;/script&gt;</pre>
						</div>
					</div>


					<!--
					<h3>Sending volatile messages.</h3>
					<p>Sometimes certain messages can be dropped. Let's say you have an app that shows realtime tweets for the keyword `bieber`.</p>
					<p>If a certain client is not ready to receive messages (because of network slowness or other issues, or because he's connected through long polling and is in the middle of a request-response cycle), if he doesn't receive ALL the tweets related to bieber your application won't suffer.</p>
					<p>In that case, you might want to send those messages as volatile messages.</p>
					-->
					<h3>揮発性メッセージの送信</h3>
					<p>ときには、メッセージが欠落しても良い場合があります。例えば `bieber` というキーワードのツイートをリアルタイムに表示するアプリが有ったとしましょう。</p>
					<p>もし特定のクライアントが(ネットワークの遅延や他の理由、もしくはロングポーリングのリクエスト-レスポンスサイクルの途中だった場合など)メッセージを受信できる状態でなかったとき、別に全部の `bieber` ツイートを受信できてなかったとしても、あまり気になりません。</p>
					<p>その場合、メッセージを揮発性メッセージとして送ることができます。</p>
					<div class="example">
						<div class="example-left-long">
							<h4>Server</h4>
							<pre class="prettyprint">var io = require('socket.io').listen(80);

io.sockets.on('connection', function (socket) {
  var tweets = setInterval(function () {
    getBieberTweet(function (tweet) {
      socket.volatile.emit('bieber tweet', tweet);
    });
  }, 100);

  socket.on('disconnect', function () {
    clearInterval(tweets);
  });
});</pre>
						</div>
					</div>


					<!--
					<h3>Sending and getting data (acknowledgements).</h3>
					<p>Sometimes, you might want to get a callback when the client confirmed the message reception.</p>
					<p>To do this, simply pass a function as the last parameter of `.send` or `.emit`. What's more, when you use `.emit`, the acknowledgement is done by you, which means you can also pass data along:</p>
					-->
					<h3>送達確認</h3>
					<p>クライアントにメッセージが届いたかどうか、コールバックで知りたい場合があるでしょう。</p>
					<p>その場合、単純に `.send` や `.emit` の最後の引数にコールバック関数を渡すだけで済みます。更に、 `.emit` 時には、そのコールバックにデータを渡すことで実行することができます。</p>
					<div class="example">
						<div class="example-left">
							<h4>Server</h4>
							<pre class="prettyprint">var io = require('socket.io').listen(80);

io.sockets.on('connection', function (socket) {
  socket.on('ferret', function (name, fn) {
    fn('woot');
  });
});</pre>
						</div>
						<div class="example-right">
							<h4>Client</h4>
							<pre class="prettyprint">&lt;script&gt;
  var socket = io.connect(); // TIP: .connect with no args does auto-discovery
  socket.on('connect', function () { // TIP: you can avoid listening on `connect` and listen on events directly too!
    socket.emit('ferret', 'tobi', function (data) {
      console.log(data); // data will be 'woot'
    });
  });
&lt;/script&gt;</pre>
						</div>
					</div>


					<!--
					<h3>Broadcasting messages.</h3>
					<p>To broadcast, simply add a `broadcast` flag to `emit` and `send` method calls. Broadcasting means sending a message to everyone else except for the socket that starts it.</p>
					-->
					<h3>メッセージのブロードキャスト</h3>
					<p>ブロードキャストは `broadcast` フラグを `emit` や `send` の前に付けるだけです。ブロードキャストとはメッセージを「それを送ってきた人」以外全員に送る事です。<p>
					<div class="example">
						<div class="example-left">
							<h4>Server</h4>
							<pre class="prettyprint">var io = require('socket.io').listen(80);

io.sockets.on('connection', function (socket) {
  socket.broadcast.emit('user connected');
});
</pre>
						</div>
					</div>


					<!--
					<h3>Using it just as a cross-browser WebSocket.</h3>
					<p>If you just want the WebSocket semantics, you can do that too. Simply leverage `send` and listen on the `message` event:</p>
					-->
					<h3>クロスブラウザ WebSocket としての利用</h3>
					<p>もし本来の WebSocket の構文と同じように使いたかったら、 `send` を使用してメッセージを送り `message` イベントを検出すれば良いだけです。</p>
					<div class="example">
						<div class="example-left">
							<h4>Server</h4>
							<pre class="prettyprint">var io = require('socket.io').listen(80);

io.sockets.on('connection', function (socket) {
  socket.on('message', function () { });
  socket.on('disconnect', function () { });
});</pre>
						</div>
						<div class="example-right">
							<h4>Client</h4>
							<pre class="prettyprint">&lt;script&gt;
  var socket = io.connect('http://localhost/');
  socket.on('connect', function () {
    socket.send('hi');

    socket.on('message', function (msg) {
      // my msg
    });
  });
&lt;/script&gt;</pre>
						</div>
					</div>
				</section>
			</div>

			<!-- browser support -->
			<div class="page" id="page-browser-support">
				<section>
					<!--
					<h2 id="transports">Supported transports</h2>
					<p>In order to provide realtime connectivity on every browser, Socket.IO selects the most capable transport at runtime, without it affecting the API. </p>
					<ul>
						<li>WebSocket</li>
						<li>Adobe® Flash® Socket</li>
						<li>AJAX long polling</li>
						<li>AJAX multipart streaming</li>
						<li>Forever Iframe</li>
						<li>JSONP Polling</li>
					</ul>
					-->
					<h2 id="transports">サポートする通信方法</h2>
					<p>全てのブラウザでリアルタイムな通信を実現するために、 Socket.IO は API に一切影響を与えることなく、環境に最も適した通信環境を選択します。</p>
					<ul>
						<li>WebSocket</li>
						<li>Adobe® Flash® Socket</li>
						<li>AJAX long polling</li>
						<li>AJAX multipart streaming</li>
						<li>Forever Iframe</li>
						<li>JSONP Polling</li>
					</ul>
				</section>
				<section>
					<h2>Supported browsers</h2>
					<h3>Desktop</h3>
					<ul>
						<li>Internet Explorer 5.5+</li>
						<li>Safari 3+</li>
						<li>Google Chrome 4+</li>
						<li>Firefox 3+</li>
						<li>Opera 10.61+</li>
					</ul>
					<h3>Mobile</h3>
					<ul>
						<li>iPhone Safari</li>
						<li>iPad Safari</li>
						<li>Android WebKit</li>
						<li>WebOs WebKit</li>
					</ul>
				</section>
			</div>

			<!-- faq -->
			<div class="page" id="page-faq">
				<section>
					<h2>FAQ</h2>

					<!--
					<h3>Does Socket.IO support cross-domain connections?</h3>
					<p>Absolutely, on every browser!</p>
					-->
					<h3>Socket.IO はクロスドメイン通信をサポートしていますか?</h3>
					<p>全てのブラウザで完璧にサポートしています!</p>

					<!--
					<h3>Why Flash?</h3>
					<p>Flash is absolutely <b>not required</b>for Socket.IO to function. If Flash is available, it'll be leveraged, as it provides almost the same capabilities as WebSocket.  If it's not, the best next transport will be chosen.</p>
					-->
					<h3>なぜ Flash なんですか?</h3>
					<p>Flash は実際は Socket.IO の機能に全く <b>必要ない</b> です。しかし、もし Flash が有効なら、 それを使えば WebSocket とほぼ同等の性能を発揮します。もし無ければ、次の通信方法が選択されるだけです。</p>

					<!--
					<h3>I want to host the Socket.IO client myself</h3>
					<p>If you're not relying on Node.JS serving Socket.IO clientside JavaScript files, make sure you set the `WEB_SOCKET_SWF_LOCATION` right after including socket.io.js with the location of the WebSocketMain.swf</p>
					<p>This is required in order for Socket.IO to find the .swf file required for Flash WebSocket.</p>
					-->
					<h3>Socket.IO のクライアントライブラリを自分でホストしたいのですが。</h3>
					<p>もし、 Node.js で Socket.IO のクライアントライブラリの JS ファイルを配らないなら、 socket.io.js をインクルードした後に `WEB_SOCKET_SWF_LOCATION` に WebSocketMain.swf のパスを設定するのを忘れないで下さい。</p>
					<p>これは Socket.IO が Flash WebSocket の実行時に .swf ファイルの場所を知るために必要です。</p>

					<!--
					<h3>Why not just call it `WebSocket` if the actual WebSocket is not present and mimick its API?</h3>
					<p>Socket.IO does more than WebSocket, even if WebSocket is selected as the transport and the user is browsing your website with an ultra modern browser. Certain features like heartbeats, timeouts and disconnection support are vital to realtime applications but are not provided by the WebSocket API out of the box.</p>
					<p>This is akin to jQuery's decision of creating a feature-rich and simple $.ajax API as opposed to normalizing XMLHttpRequest.</p>
					-->
					<h3>なぜ `WebSocket` とは呼ばないんですか？ もし実際に WebSocket が使えなくても、その API を真似るため?</h3>
					<p>Socket.IO は WebSocket より多くの機能を提供します。WebSocket が通信方法に選択され、ユーザが超モダンなブラウザでそのサイトを見ていたとしてもです。例えば、ハートビート、タイムアウトや切断のサポートはリアルタイムアプリを作る上では非常に重要ですが、 WebSocket の API では、そのままでは提供されていません。</p>
					<p>これは、 jQuery が $.ajax という多機能かつシンプルな API で通常の XMLHttpRequest を抽象化しているのと同じ考え方です。</p>
				</section>
			</div>
		</div>

		<footer>
			<p>
				Socket.IO by <a href="http://devthought.com">Guillermo Rauch</a>
				at <a href="http://learnboost.com">gradebook</a> <a href="http://github.com/learnboost/">LearnBoost Labs</a>.
				Released under the MIT license -  Copyright <a href="http://learnboost.com">LearnBoost 2012</a>
			</p>
			<p>
				このページは <a href="http://socket.io">Socket.IO</a> の翻訳ページです。本ページの内容は、本家と同じ MIT ライセンスとします。
			</p>
		</footer>

		<a id="fork-me" href="http://github.com/learnboost/socket.io">
			<img src="images/forkme.png" alt="Fork me on GitHub">
		</a>

		<script src="js/prettify.js"></script>
		<script src="js/main.js"></script>
		<script type="text/javascript">
			var _gaq = _gaq || [];
			_gaq.push(['_setAccount', 'UA-18488944-1']);
			_gaq.push(['_trackPageview']);
			(function() {
				var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
				ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
				var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
			})();
		</script>
	</body>
</html>
